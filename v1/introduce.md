主要框架如上图所示，主要就是维护一个哈希桶 MemoryPools，里面每项对应一个内存池 MemoryPool，哈希桶中每个内存池的块大小 BlockSize 是相同的（4096字节，当然也可以设置为不同的），但是每个内存池里每个块分割的大小（槽大小）SlotSize是不同的，依次为8,16,32,...,512字节（需要的内存超过512字节就用new/malloc），用户申请不同大小的内存就通过哈希桶的映射找到相应（槽大小）  SlotSize 的内存池向其申请，比如用户分别申请8字节和12字节的内存，则经过哈希函数的计算找到槽大小为8字节的内存池和槽大小为16字节（哈希函数向上取整，因为分配给用户的内存块只能大不能小）的内存池分别分配内存给用户，这样设置的好处是可以保证内存碎片在可控范围内。
注：到这里大家可能想问为什么用户申请超过512字节的内存就直接调用 new/malloc 等系统调用？
答：因为内存池主要解决的是 小内存带来的内存碎片问题 和 小内存频繁申请释放带来的性能问题。但如果是用户申请较大块的内存依然选择通过内存池分配内存则会导致内存池频繁因为管理的内存不足而向系统申请内存，这样既没有起到性能优化的作用同时增加的程序的复杂度。(ps：频繁申请小内存带来的问题可参考：https://blog.csdn.net/LF_2016/article/details/53511648)
介绍完大致框架之后再来看一下每个内存池的内部结构图：
主要的对象有：指向第一个可用内存块的指针Slot currentBlock（也是图中的ptr to firstBlock），被释放对象的slot链表Slot freeSlot，未使用的slot链表Slot* currentSlot，下面讲下具体的作用：
● Slot currentBlock：内存池实际上是一个一个的 Block 以链表的形式连接起来，每一个 Block 是一块大的内存，当内存池的内存不足的时候，就会向操作系统申请新的 block 加入链表。
● Slot freeSlot：链表里面的每一项都是对象被释放后归还给内存池的空间，内存池刚创建时 freeSlot 是空的。用户创建对象，将对象释放时，把内存归还给内存池，此时内存池不会将内存归还给系统（delete/free），而是把指向这个对象的内存的指针加到 freeSlot 链表的前面（前插），之后用户每次申请内存时，memoryPool就先在这个 freeSlot 链表里面找。
● Slot curretSlot：用户在创建对象的时候，先检查 freeSlot 是否为空，不为空的时候直接取出一项作为分配出的空间。否则就在当前 Block 将 currentSlot 所指的内存分配出去，如果 Block 里面的内存已经使用完，就向操作系统申请一个新的 Block。
上述两个图已经大致介绍了该项目的结构，下面我将以一个整体流程图解读的方式，给大家介绍该内存池项目：

该项目对外提供了两个重要的接口newElement和deleteElement，分别是向内存池申请内存和将申请的内存进行回收操作。
首先介绍newElement函数，其函数声明如下：
template<typename T, typename... Args>
T* newElement(Args&&... args);
用户在构造对象T的时候通过调用newElement<T>()方法申请内存，newElement<T>()方法计算出元素T的大小后传入哈希桶中，哈希桶中根据哈希映射选择相应槽大小的内存池去分配内存返回（分配内存时优先使用FreeList_里的空闲内存槽，其次再找curSlot_，如果curSlot_大于等于lastSot_，则重新申请一块内存块来分配内存槽），newElement函数获得内存之后，在该内存上构造对象T后将地址返回给用户。
其次是介绍deleteElement函数，其函数声明如下：
template<typename T>
void deleteElement(T* p);
当用户想要释放对象时可调用deleteElement函数，该方法首先调用对象T的析构函数，其次同样经过哈希映射找到相应的内存池去把内存槽加入到FreeList_中。